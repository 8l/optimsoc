\chapter{Installation \& Configuration}
\label{chap:installation}

Before you get started with OpTiMSoC you should notice that external
tools and libraries might be required that are in some cases
proprietary and cost some money. Although OpTiMSoC is developed at an
university with access to many EDA tools, we aim to always provide
tool flows and support for open and free tools, but especially when it
comes to synthesis such alternatives are even not available.

\section{Prerequisites}

Throughout this document some packages are required in your Linux
distribution. OpTiMSoC should principally work on all common Linux
distributions. In case you encounter problems in your system we highly
encourage you to contact the OpTiMSoC maintainers to fix these
problems. Nevertheless, we recommend Ubuntu 12.04 LTS as development
system and can ensure OpTiMSoC will work on it as we also work on it.
In the following we will refer to Ubuntu/Debian commands to install
packages, that will run under Ubuntu 12.04 LTS.

Independent of the components you plan to use, you will need some
packages to be installed:

\begin{alltt}
\$> sudo apt-get -y install git g++ python libtool automake autoconf \textbackslash
   libusb-1.0-0-dev libreadline6-dev cmake sdcc
\end{alltt}

\section{Get OpTiMSoC}

OpTiMSoC does not come as an installation package, but is distributed
as a git\footnote{http://www.git-scm.org} repository. The repository
is needed for two purposes. First, it is the installation source for
tools and libraries. Second, the hardware sources, applications
etc. are contained there to create your OpTiMSoC systems.

It is generally a good idea to understand git, especially when you
plan to contribute to OpTiMSoC. Nevertheless, we will give a more
detailed explanation of how to get your personal copies of OpTiMSoC
and (potentially) update them.

Before you get started, you should clone the LISNoC and OpTiMSoC
repository:

\begin{verbatim}
$> git clone http://lis.ei.tum.de/git/lisnoc.git
$> git clone http://lis.ei.tum.de/git/optimsoc.git
\end{verbatim}

After cloning you will have the main branch at its latest state. This
should in general work then, but to ensure you are on a certain
release you can set the state of the repository accordingly.

You can list all releases:

\begin{verbatim}
$> git tag
\end{verbatim}

The release tags have the form \texttt{rel\emph{yyyymmdd}} where
\texttt{\emph{yyyy}} is the year, \texttt{\emph{mm}} is the month and
\texttt{\emph{dd}} is the day of the release.

You can set each of the repositories to a certain release, e.g.,

\begin{alltt}
\$> git checkout rel\emph{yyyymmdd}
\end{alltt}

As a starter, it is recommended that you set your repositories to the
latest release, which is always available as \texttt{rel-current}:

\begin{alltt}
\$> git checkout rel-current
\end{alltt}

For all work with OpTiMSoC you will need to have both repositories
available.

In the future it is necessary for some scripts to know where to find
everything. Therefore you need to set the following environement
variables (e.g., in your \verb|.bashrc|):

\begin{alltt}
export LISNOC=\emph{/path/to/lisnoc/clone}
export LISNOC_RTL=\$\{LISNOC\}/rtl

export OPTIMSOC=\emph{/path/to/optimsoc/clone}
export OPTIMSOC_RTL=\$\{OPTIMSOC\}/src/rtl
export OPTIMSOC_SYSC=\$\{OPTIMSOC\}/src/sysc
\end{alltt}

With the environment variables set, you can start using OpTiMSoC.

\section{OpTiMSoC Installation Path}

As mentioned before, some libraries and tools need to be built and
then also installed. Those are used for all platforms you then create
from the source tree.

You can install the files whereever you want as some environment
variables (\verb|PATH|, \verb|PKG_CONFIG_PATH|, etc.) help finding
them. Throughout this document we will use

\begin{alltt}
/opt/optimsoc
\end{alltt}

as installation path.

\section{OpTiMSoC Toolchain}

The toolchain of OpTiMSoC currently consists of the standard OpenRISC
crosscompiler and a newlib port (based on the OpenRISC newlib) plus a
few small utility programs and scripts.

\subsection{Prerequisites}

In Ubuntu 12.04 LTS (and of course anywhere else) you will need
libgmp, install

\begin{verbatim}
$> sudo apt-get install libgmp3c2
\end{verbatim}

\subsection{Compiler and C Library}

In most cases you will not need to build the entire toolchain from
scratch, because three options are available:

\begin{itemize}
\item Download the entire toolchain
\item Build the newlib with your OpenRISC toolchain
\item Build everything from scratch
\end{itemize}

\subsubsection{Option 1: Download the entire toolchain}
First of all you need the OpenRISC crosscompiler. There are many
options available to get it or build
it\footnote{\url{http://opencores.org/or1k/OpenRISC_GNU_tool_chain}}.
The most simple approach is to download the prepacked
library\footnote{\url{ftp://ocuser:ocuser@openrisc.opencores.org/toolchain/openrisc-toolchain-ocsvn-rev789.tar.bz2}
  Mirror:
  \url{http://lis.ei.tum.de/pub-download/mirror/opencores/openrisc-toolchain/openrisc-toolchain-ocsvn-rev789.tar.bz2}}
and extract it to \verb|/opt|.

\begin{alltt}
\$> cd /opt
\$> sudo tar -xjf openrisc-toolchain-ocsvn-rev789.tar.bz2
\end{alltt}

Next you need our prepacked newlib library. Download the current
version\footnote{\url{http://lis.ei.tum.de/pub-download/optimsoc/toolchain/newlib/optimsoc-newlib-current.tgz}}
and extract it to \verb|/opt|.

Set environment (e.g., in \verb|~/.bashrc|):

\begin{alltt}
export PATH=/opt/openrisc/toolchain/bin:\$\{PATH\}
export OPTIMSOC_NEWLIB=/opt/optimsoc/newlib
\end{alltt}

\subsubsection{Option 2: Build newlib for OpTiMSoC}

Clone the development from the repository to a directory suitable for
you:

\begin{verbatim}
$> git clone http://lis.ei.tum.de/git/optimsoc-toolchain.git
\end{verbatim}

Go to the newlib directory:

\begin{verbatim}
$> cd optimsoc-toolchain/newlib-1.18.0
\end{verbatim}

Two different targets need to be build:
\begin{itemize}
\item the baremetal library which includes the exception vectors etc.
  (\verb|newlib-baremetal|).
\item the library for the (virtual) applications which uses syscalls
  etc.  (\verb|newlib-virtualapps|)
\end{itemize}

You will need to build both of them separately. First create a build
directory for the baremetal, configure and build:

\begin{verbatim}
$> mkdir build-baremetal; cd build-baremetal
$> ../configure --target=optimsoc-baremetal \
    --prefix=/opt/optimsoc/newlib \
    CC_FOR_TARGET=or32-elf-gcc AR_FOR_TARGET=or32-elf-ar \
    RANLIB_FOR_TARGET=or32-elf-ranlib
$> make
$> make install
\end{verbatim}

Next you need to build the second version of the newlib. Start from
the newlib toplevel again:

\begin{verbatim}
$> mkdir build-virtualapps; cd build-virtualapps
$> ../configure --target=optimsoc-virtualapps \
    --prefix=/opt/optimsoc/newlib \
    CC_FOR_TARGET=or32-elf-gcc AR_FOR_TARGET=or32-elf-ar \
    RANLIB_FOR_TARGET=or32-elf-ranlib --enable-newlib-multithread
$> make
$> make install
\end{verbatim}

Set environment (e.g., in \verb|~/.bashrc|):

\begin{verbatim}
export OPTIMSOC_NEWLIB=/opt/optimsoc/newlib
\end{verbatim}


\subsubsection{Option 3: Build the whole toolchain}

In one of the next releases we will have machine support, e.g.,
\verb|or32-elf-gcc -moptimsoc|.

\subsection{TCL Environment \& Additional Scripts}

In the EDA field TCL is still the scripting language of choice.
Fortunately, all of the EDA tools have a TCL scripting interface. To
allow for easier creation of projects and compile RTL sources we added
some TCL scripts for all modules and targets. Beside the TCL scripts
some Python scripts and utility programs are required by the OpTiMSoC
platforms.

To install the tools simply run

\begin{alltt}
\$> \$OPTIMSOC/tools/install.sh /opt/optimsoc
\end{alltt}

or replace your installation path accordingly.

\begin{alltt}
OPTIMSOC_TCL=/opt/optimsoc/tools/tcl
PATH=\$PATH:/opt/optimsoc/tools/utils
\end{alltt}

\subsection{System Software}

The system software consist of the libraries itself and build
infrastructure for your applications.

The installation of the system software starts in the base folder
(relative to the OpTiMSoC root) \verb|src/sw/system/|.

%Autotools are used to check your platform and generate the configure
%and the Makefiles:

%\begin{alltt}
%\$> ./autogen.sh
%\end{alltt}

%The rest of the installation is straight forward.

To perform the installation run:

\begin{verbatim}
$> mkdir build
$> cd build
$> ../configure --prefix=/opt/optimsoc/systemsw/ --host=or32-elf \
    CC=or32-elf-gcc
$> make
$> make install
\end{verbatim}

Configuration may fail when you did not set the \verb|OPTIMSOC_NEWLIB|
environment variable.

\subsection{Configuration}

After you installed the toolchain and compiled additional scripts, you
need to enable them in your system. When you followed the steps above
you will have to add the environment variables as (example for bash):

\begin{alltt}
# OpTiMSoC toolchain
export PATH=/opt/openrisc/toolchain/bin:/opt/optimsoc/tools/utils:\$\{PATH\}
export OPTIMSOC_NEWLIB=/opt/optimsoc/newlib
export OPTIMSOC_TCL=/opt/optimsoc/tools/tcl
export PKG_CONFIG_PATH=/opt/optimsoc/systemsw/share/pkgconfig
\end{alltt}

\section{Host Software}

The host software allows you to communicate with the system for
control and debugging/diagnosis. \verb|liboptimsochost| is the basic
library, which also has a command line interface. A graphical user
interface complements this for easier visualization of the system.

\subsection{liboptimsochost}

The library is found in \verb|src/sw/host/liboptimsochost|.  Some
tools are included with the library, the most important is the command
line interface \verb|optimsoc_cli|. It can be used to communicate with
the OpTiMSoC debug system on the command line. Recently, a Python
scripting interface has been added. You will need the python
development libraries for this to work when enabled via
\verb|--enable-python-interface|.

Build, make and install:

\begin{verbatim}
$> mkdir build
$> cd build
$> ../configure --prefix=/opt/optimsoc/host/ --enable-python-interface
$> make
$> make install
\end{verbatim}

Before proceeding you will need to set the correct paths:

\begin{verbatim}
export LD_LIBRARY_PATH=/opt/optimsoc/host/lib:${LD_LIBRARY_PATH}
export PATH=/opt/optimsoc/host/bin:${PATH}
\end{verbatim}

\subsection{Graphical User Interface}

\subsubsection{Prerequisites}

For building you will need Qt:

\begin{alltt}
\$> sudo apt-get install libqt4-dev
\end{alltt}

In case you want to develop the GUI, install qtcreator:

\begin{alltt}
\$> sudo apt-get install qtcreator
\end{alltt}

\subsubsection{Building}

The graphical user interface resides in
\verb|src/sw/host/optimsocgui|. We use cmake here as it better
integrates with the Qt toolchain (which is used for the GUI).

To build it:

\begin{alltt}
\$> mkdir build
\$> cd build
\$> cmake -DCMAKE_INSTALL_PREFIX:PATH=/opt/optimsoc/host ..
\$> make
\$> make install
\end{alltt}

Afterwards you will find \verb|optimsocgui| in
\verb|src/sw/host/optimsocgui/bin|.

\section{ZTEX Tools}

In case you are running the bitstreams on the FPGA you will need the
ZTEX toolchain as it can be downloaded at \url{http://www.ztex.de}. We
will in the following assume you downloaded it and unpacked it to
\verb|/opt/ztex/| so that the folder \verb|/opt/ztex/java| exists. You
will need to set the path accordingly:

\begin{alltt}
export PATH=/opt/ztex/bin:/opt/ztex/java/FWLoader:\$\{PATH\}
\end{alltt}

Furthermore you will need the small device compiler \verb|sdcc|.

\section{SystemC, Verilator and SystemC Libraries}

SystemC\footnote{\url{http://www.systemc.org}} is used as simulation
library for both full system simulation based on Verilator and in
future for abstracted simulations. In case you want to use either of
them, you will therefore need to download, compile and install
SystemC.

In case you want to run the Verilator-based simulation examples or
develop software using the Verilator-based simulation, you will need
to download and compile Verilator too.

In the following the installation to \verb|/opt| is assumed, change
the folder if necessary.

\subsection{SystemC}

First you need to register at the SystemC website and download the
SystemC package (\verb|systemc-2.3.0.tgz|). For installation create
the base folder and build directory:

\begin{alltt}
\$> sudo mkdir /opt/systemc
\$> sudo mkdir /opt/systemc/2.3.0
\$> sudo mkdir /opt/systemc/build
\end{alltt}

Copy the gzip file from above to the build dir, become superuser, move
there and extract it:

\begin{alltt}
\$> sudo cp systemc-2.3.0.tgz /opt/systemc/build
\$> cd /opt/systemc/build
\$> sudo tar -xzf systemc-2.3.0.tgz
\end{alltt}

Create a build object directory, configure in there, build, install,
done!

\begin{alltt}
\$> cd systemc-2.3.0
\$> sudo mkdir objdir
\$> sudo cd objdir
\$> sudo ../configure --prefix=/opt/systemc/2.3.0
\$> sudo make
\$> sudo make install
\end{alltt}

You will now find SystemC in \verb|/opt/systemc/2.3.0|.

\subsection{Verilator}

First clone the Verilator repository in \verb|/opt|.

\begin{alltt}
\$> cd /opt
\$> sudo git clone http://git.veripool.org/git/verilator
\end{alltt}

Switch to the Verilator directory, prepare the build in place and make:

\begin{alltt}
\$> sudo -s
\$> cd verilator
\$> sudo aclocal
\$> autoconf
\$> ./configure
\$> make
\$> exit
\end{alltt}

\subsection{OpTiMSoC SystemC library}

The OpTiMSoC SystemC library contains SystemC modules for Debugging of
Verilated Systems, Simulations and other. It can be found in
\verb|src/sysc/|. The build is identical to the other libraries

\begin{alltt}
\$> ./autogen.sh
\$> mkdir build
\$> cd build
\$> ../configure --prefix=/opt/optimsoc/sysc \textbackslash
      --with-systemc-inc-dir=\$\{SYSTEMC\}/include \textbackslash
      --with-systemc-lib-dir=\$\{SYSTEMC\}/lib-linux
\$> make
\$> make install
\end{alltt}

\subsection{Configuration}

You will need the following environment variables (e.g., in bash):

\begin{alltt}
# SystemC environment
export SYSTEMC=/opt/systemc/2.3.0
export SYSTEMC_INCLUDE=\$\{SYSTEMC\}/include

# Verilator environment
export VERILATOR\_ROOT=/opt/verilator
export PATH=\$\{VERILATOR_ROOT\}/bin:\$\{PATH\}
\end{alltt}

\section{Configuration Summary}

Check that you have the following environment variables set at this
point (or a subset depending on your requirements):

\begin{alltt}
export LISNOC=\emph{/path/to/lisnoc/clone}
export LISNOC_RTL=\$\{LISNOC\}/rtl

export OPTIMSOC=\emph{/path/to/optimsoc/clone}
export OPTIMSOC_RTL=\$\{OPTIMSOC\}/src/rtl
export OPTIMSOC_SYSC=\$\{OPTIMSOC\}/src/sysc

# Your OpTiMSoC installation path
export OPTIMSOC_INSTALL=/opt/optimsoc

# OpTiMSoC toolchain
export PATH=/opt/openrisc/toolchain/bin:\$\{OPTIMSOC_INSTALL\}/tools/utils:\$\{PATH\}
export OPTIMSOC_NEWLIB=\$\{OPTIMSOC_INSTALL\}/newlib/

# TCL scripting
export OPTIMSOC_TCL=\$\{OPTIMSOC_INSTALL\}/tools/tcl

# SystemC environment
export SYSTEMC=/opt/systemc/2.3.0
export SYSTEMC_INCLUDE=\$\{SYSTEMC\}/include

# Verilator environment
export VERILATOR\_ROOT=/opt/verilator
export PATH=\$\{VERILATOR_ROOT\}/bin:\$\{PATH\}

# System software
export PKG_CONFIG_PATH=\$\{OPTIMSOC_INSTALL\}/systemsw/share/pkgconfig

# Host library, tools and GUI
export LD_LIBRARY_PATH=\$\{OPTIMSOC_INSTALL\}/host/lib:\$\{LD_LIBRARY_PATH\}
export PATH=\$\{OPTIMSOC_INSTALL\}/bin:\$\{PATH\}
\end{alltt}

\section{Upgrade from rel-20130620}

\begin{itemize}
\item The in-place installation has been changed to a unified
  installation tree. You should reinstall.
\item The newlib has changed to a baremetal and virtualapps. You need
  to rebuild and install to different paths.
\item The system software structure has been changed. We removed the
  distinction between distributed and shared memory. Furthermore we
  have baremetal and virtualapps here also. You need to rebuild.
\item The TCL interface has been added. Set \verb|OPTIMSOC_TCL| as
  described above.
\item The previous liboptimsochost examples are now part of the
  distribution as ``tools''. Please rebuild the library.
\end{itemize}